{
  "hash": "d77cede0b43b12f64f635068f04088b8",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: Sarah Zeller\ntitle: \"Reading a `csv` file with 2-row column names\"\ndescription: \"Sometimes, `csv` files have 2-row column names. I create a function to deal with this.\"\ndate: \"2024-05-05\"\ncategories: [code, data]\nimage: \"two_row_colnames.PNG\"\ncitation: \n  url: https://sarahzeller.github.io/blog/posts/reading-csv-with-2row-colnames/\n\nformat:\n  html:\n    toc: true\n\nexecute:\n  warning: false\n  \neditor: \n  markdown:\n    wrap: sentence\n---\n\n\nI recently wanted to check out election results from the last German *Bundestag* election, and read them into `R`.\nThe data was saved in a `csv` file -- so far, so good.\nBut the column names were spread over two rows.\nðŸ˜±\n\nThis means I'm losing valuable information if I'm only reading the first row of column names.\nAdditionally, the types of the rows get messed up, since the second row of the column names is read as data -- specifically, `character` data.\n\nSo, I wanted to combine both rows of column names into one.\nHere's how I did it in R.\n\n# Data\n\nYou'll find the `csv` file I was trying to read [here](https://www.bundeswahlleiterin.de/dam/jcr/62868510-b616-443c-97b4-71847916d543/btw2021_brief_wkr.csv).\nIt shows the federal election results, aggregated to the level of the electoral districts.\nIn Germany, you have two votes: the first one is for a candidate, the second one for a party.\nHere's a snapshot of the file when you load it into `Excel` .\n\n![](two_row_colnames.PNG)\n\nYou can see two issues.\n\n1.  The copyright information and title are saved in column `A` (rows 1 and 3).\n    We can solve this easily by skipping over those rows when we read the `csv` file into R.\n\n2.  The column names are spread over two rows: 4 and 5.\n    This issue, we can't solve that quickly.\n\nSo let's check out the structure of the column names.\nThe columns A--F that only need one row for the column names identify the voting district; the columns that follow identify the results.\nRow 6 always indicates whether it's the first or second vote result.\n\n::: callout-note\nTwo-row column names are not always so clearly structured.\n:::\n\nSo what's the plan?\nWe want to do the following:\n\n1.    Read the first column name row.\n2.    Read the second column name row.\n3.    Combine those two rows into one.\n4.    Read the data into R.\n5.    Replace the column names with the combined column names.\n\nLet's get started ðŸš€\n\n# Preparation\n\nLet's load the data first.\nWe'll create a `temp_file` to store the data, but feel free to download it into any folder you like.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_file <- tempfile(fileext = \".csv\")\ndownload.file(url = \"https://www.bundeswahlleiterin.de/dam/jcr/62868510-b616-443c-97b4-71847916d543/btw2021_brief_wkr.csv\",\n              destfile = temp_file)\n```\n:::\n\n\nNext, let's load the needed packages.\nWe'll use `janitor` to clean the column names, `tidyr` and `dplyr` to combine the two rows, and `rlang` to set the correct names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(rlang)\n```\n:::\n\n\n\n# Reading the column names\n\n## Reading the first row\n\nThere's probably many ways to do this, but I decided to go for the following approach: \n\n1. read in the `csv` file starting at the first column name row\n2. clean the column names\n3. store the column names in a variable\n\nTo read in the first row of column names, we can use the `read.csv2()` function.\nWe'll skip the first three rows (which only contain metadata) and read in only one row, since we don't need the content for now.\nThen, we'll clean the column names with `janitor::clean_names()` to make sure that they're formatted like we want them to.\nLastly, I'm removing the numbers that are attached at the end since some of the variable names so far are not unique (since they're still missing the second row).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames_row1 <- read.csv2(temp_file, skip = 4, nrows = 1) |>\njanitor::clean_names() |> \n  colnames() |> \n  gsub(\"_[[:digit:]].*\", \"\", x = _) \n```\n:::\n\n\n## Reading both column names\n\nWe could repeat this procedure for the second row of column names.\nHowever, it's better to create a function for this case.\nWe simply take the pipeline from before and put it into a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_colnames <- function(path, skip_rows = 4, no_rows = 1) {\n  path |> \n    read.csv2(skip = skip_rows, nrows = no_rows) |> \n    janitor::clean_names() |> \n    colnames() |> \n    gsub(\"_[[:digit:]].*\", \"\", x = _)\n}\n```\n:::\n\n\n# Combine the row names\n\nNow, we can easily read in both rows of column names using this function.\nAll we need to do is change the number of rows to skip.\nWe'll put them in a `data.frame` together so we can manipulate them easily.\n\nTo bring the two rows together, we simply check if there's actually anything inside `row_2` (i.e. something that is not parsed as `\"x\"`).\nIf there is not, we just take the contents of `row_1`.\nOtherwise, we paste `row_1` and `row_2` together.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames <- data.frame(\n  row_1 = read_colnames(temp_file, skip_rows = 4),\n  row_2 = read_colnames(temp_file, skip_rows = 5)\n) |>\n  mutate(colnames = ifelse(row_2 == \"x\", \n                           row_1, \n                           paste(row_1, row_2, sep = \"_\")))\n\nrownames |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            row_1 row_2        colnames\n1    wahlkreis_nr     x    wahlkreis_nr\n2   wahlkreisname     x   wahlkreisname\n3            land     x            land\n4  wahlbezirksart     x  wahlbezirksart\n5 wahlberechtigte     x wahlberechtigte\n6        wahlende     x        wahlende\n```\n\n\n:::\n:::\n\n\nYay, now we have the column names we want in a single vector -- `rownames$colnames` ðŸ¥³\nAll that's left to do is to read in the data and replace the column names.\n\n# Read in the data and replace the column names\n\nLet's read in the data.\nWe'll skip the first three rows and the first row of column names.\nThen, we'll replace the column names with the combined column names.\n\nAnd there we go -- a properly read in `csv` file with two-row column names ðŸŽ‰\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvote_results <- read.csv2(temp_file, skip = 5) |>\n  setNames(rownames$colnames)\n  \nvote_results |>\n  select(1:2, 7) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  wahlkreis_nr                     wahlkreisname ungultige_erststimmen\n1            1             Flensburg â€“ Schleswig                  1270\n2            2 Nordfriesland â€“ Dithmarschen Nord                  1002\n3            3      Steinburg â€“ Dithmarschen SÃ¼d                  1037\n4            4             Rendsburg-EckernfÃ¶rde                  1092\n5            5                              Kiel                   853\n6            6                 PlÃ¶n â€“ NeumÃ¼nster                  1307\n```\n\n\n:::\n:::\n\n\n# One step further -- considering the second row meaning\n\nIn this specific data set, the second row of the column names has a specific meaning: \n\n-   `erststimmen` indicates the first vote\n-   `zweitstimmen` indicates the second vote\n\nWe can disentangle the data set to respect this information.\nSince the names contain underscores that are apart from the one separating the first and second row, we'll go a bit hacky here and replace the underscore before `erststimme` or `zweitstimme` with a dot.  \nThen, we'll pivot the data longer to separate the party from the vote type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvote_results_clean <- vote_results |> \n  rename_at(vars(matches(\"stimmen\")), ~ stringr::str_replace(.x, \"_([erst|zweit])\", \".\\\\1\")) |>\n  pivot_longer(cols = matches(\"stimmen\"),\n               names_to = c(\"vote_receiver\", \"vote_type\"),\n               names_sep = \"\\\\.\",\n               values_to = \"vote_count\"\n               )\n```\n:::\n\n\nAnd there we have it -- a clean data set with the correct column names and the vote type separated.\nYay!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvote_results_clean |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 9\n  wahlkreis_nr wahlkreisname       land  wahlbezirksart wahlberechtigte wahlende\n         <int> <chr>               <chr> <chr>                    <int>    <int>\n1            1 Flensburg â€“ Schlesâ€¦ SH    Urne                    231536   127698\n2            1 Flensburg â€“ Schlesâ€¦ SH    Urne                    231536   127698\n3            1 Flensburg â€“ Schlesâ€¦ SH    Urne                    231536   127698\n4            1 Flensburg â€“ Schlesâ€¦ SH    Urne                    231536   127698\n5            1 Flensburg â€“ Schlesâ€¦ SH    Urne                    231536   127698\n6            1 Flensburg â€“ Schlesâ€¦ SH    Urne                    231536   127698\n# â„¹ 3 more variables: vote_receiver <chr>, vote_type <chr>, vote_count <int>\n```\n\n\n:::\n:::\n\n\n# An alternative\n\nI only found out later that there's actually a whole package dedicated to reading in files with odd formatting, including two-row column names: [`unheadr`](https://github.com/luisDVA/unheadr).\nIt's a great package that does exactly what we did here -- and more.\n\nIf you want to use it specifically for column names with more than one row to them, you can use their function `mash_colnames`; it does pretty much what we did here, and extends the functionality to column names with more than two rows.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}